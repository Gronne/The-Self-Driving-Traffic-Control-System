
class CSVCityMapFile
	types
		csv_header_t = (IFile`string_t | Speed`speed_t | Length`length_t); -- Remember to try and change to a single string_t instead of three
		
		protected row_object :: From	: IFile`string_t | Identification`ID_t
												 		To		:	IFile`string_t | Identification`ID_t
											   		Direction		: IFile`string_t
											 	 		SpeedLimit	: Speed`speed_t
												 		Length	: Length`length_t;
									
	values
		bi_directional = "bi";
		mono_directional = "mono";
		
	functions
		public getElementIndexInSeq : seq of ? * ? -> nat1
			getElementIndexInSeq(sequence, element) == let index in set inds sequence be st sequence(index) = element in index;
			
		protected validRows : seq of row_object -> bool
			validRows(rows) == forall row in seq rows & 
																			(row.Direction = bi_directional or row.Direction = mono_directional) and 
																			row.SpeedLimit > 0 and
																			row.Length > 0;

	operations
	
		static public load : IFile`string_t ==> CityMap
			load(name) == (
				return load("", name);
			);
			
		static public load : IFile`string_t * IFile`string_t ==> CityMap
			load(address, name) == (
				dcl csvRows : seq of row_object := CSVCityMapFile`loadCsvRows(address, name);
				dcl cityMap : CityMap := CSVCityMapFile`csvRows2CityMap(csvRows);
				return cityMap;
			);
			
		static public save : IFile`string_t * CityMap ==> ()
			save(name, cityMap) == (
				save("", name, cityMap);
			);
			
		static public save : IFile`string_t * IFile`string_t * CityMap ==> ()
			save(address, name, cityMap) == (
				dcl csvRows : seq of row_object := CSVCityMapFile`cityMap2CsvRows(cityMap);
				saveCsvRows(address, name, csvRows);
			);
			
			
			
			
		static protected loadCsvRows : IFile`string_t * IFile`string_t ==> seq of row_object
			loadCsvRows(address, name) == (
				dcl file_name : IFile`string_t := address ^ name;
				let mk_(ok,lines) = CSV`flinecount(file_name)
			    in
			      if ok 
			      then (
			      			dcl rows : seq of row_object := [];
			            for i = 2 to lines do
				             let mk_(ok,[From,To,Direction,SpeedLimit,Length]) = CSV`freadval[seq of csv_header_t](file_name,i)
				             in 
				             		rows := rows ^ [mk_row_object(From, To, Direction, SpeedLimit, Length)];
				          return rows;
			           )
			      else error;
			)
			post validRows(RESULT);
						
			
		static protected saveCsvRows : IFile`string_t * IFile`string_t * seq of row_object ==> ()
			saveCsvRows(address, name, csvRows) == (
				dcl file_name : IFile`string_t := address ^ name;
				dcl status : bool := CSV`fwriteval(file_name, ["From", "To", "Direction", "SpeedLimit", "Length"], <start>);
				for row in csvRows do status := CSV`fwriteval(file_name, [row.From, row.To, row.Direction, row.SpeedLimit, row.Length], <append>);
				return;
			)
			pre validRows(csvRows);
			
			
		static protected csvRows2CityMap : seq of row_object ==> CityMap
			csvRows2CityMap(rowObjects) == (
				dcl cityMap : CityMap := new CityMap();
				dcl uniqueIDs : set of (IFile`string_t | Identification`ID_t) := { row.From | row in seq rowObjects } union { row.To | row in seq rowObjects };
				for all id in set uniqueIDs do cityMap.addIntersection(new Intersection(id));
				for row in rowObjects do (
						dcl road : Road := new Road(row.Length, row.SpeedLimit);
						dcl interFrom : Intersection := new Intersection(row.From);
						dcl interTo : Intersection := new Intersection(row.To);
						if row.Direction = bi_directional then 
								cityMap.addRoad(road, interTo, interFrom);
						cityMap.addRoad(road, interFrom, interTo);
					);
				return cityMap;
			);
			
		static protected cityMap2CsvRows : CityMap ==> seq of row_object
			cityMap2CsvRows(cityMap) == (
				dcl rows : seq of row_object := [];
				for all intersection in set cityMap.getSetOfInter() do (
						dcl roads : seq of Road := cityMap.getSeqOfRoad(intersection);
						for road in roads do (
							dcl interA : Intersection := cityMap.getInterTupleFromRoad(road).#1;
							dcl interB : Intersection := cityMap.getInterTupleFromRoad(road).#2;
							dcl row : row_object := mk_row_object( interA.getID(), interB.getID(), mono_directional, road.getSpeedLimit(), road.getLength() );
							
							if card ({row} union elems rows) <> card elems rows then 
									rows := rows ^  [row]
							else 
									rows(getElementIndexInSeq(rows, row)).Direction := bi_directional;
						);
				);
				return rows
			);


end CSVCityMapFile